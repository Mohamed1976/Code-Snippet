using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Text;
using System.Threading;

//Press ALT + F2 to start diagnostics support in Visual Studio 2019 
//Note that, as with security, diagnostics support should be “designed in” to an
//application at the start of the development.The amount of effort to be applied
//creating diagnostic elements should be weighed against the risk and impact of
//problems with different parts of a solution.
//You can also use information generated by logging and tracing to investigate
//performance issues with systems out in the field.
//The System.Diagnostics namespace contains Debug and Trace classes that can
//be used to trace execution of a program.


namespace _70_483.Diagnostics
{
    public class DiagnosticsExamples
    {
        public DiagnosticsExamples()
        {

        }

        private static PerformanceCounter TotalImageCounter;
        private static PerformanceCounter ImagesPerSecondCounter;
        private enum CreationResult
        {
            CreatedCounters,
            LoadedCounters
        };

        private static CreationResult SetupPerformanceCounters()
        {
            string categoryName = "Image Processing";

            if (PerformanceCounterCategory.Exists(categoryName))
            {
                // production code should use using
                TotalImageCounter = new PerformanceCounter(categoryName: categoryName,
                    counterName: "# of images processed",
                    readOnly: false);

                // production code should use using
                ImagesPerSecondCounter = new PerformanceCounter(categoryName: categoryName,
                    counterName: "# images processed per second",
                    readOnly: false);
                return CreationResult.LoadedCounters;
            }
            else
            {
                //There are a number of different types of counter that can be created.The
                //program above uses two types of counter. The counter that counts the number of
                //images processed is the NumberOfItems64 type, which counts using a 64 bit
                //integer.The counter that counts the number of images being processed per
                //second is a RateOfCountsPerSecond32 that averages the number of updates per
                //second to the counter.
                CounterCreationData[] counters = new CounterCreationData[] 
                {
                    new CounterCreationData(counterName:"# of images processed", 
                        counterHelp:"number of images resized",
                        counterType:PerformanceCounterType.NumberOfItems64),

                    new CounterCreationData(counterName: "# images processed per second",
                        counterHelp:"number of images processed per second",
                        counterType:PerformanceCounterType.RateOfCountsPerSecond32)
                };
                
                CounterCreationDataCollection counterCollection = new CounterCreationDataCollection(counters);
                
                PerformanceCounterCategory.Create(categoryName: categoryName,
                    categoryHelp: "Image processing information",
                    categoryType: PerformanceCounterCategoryType.SingleInstance,
                    counterData: counterCollection);                
                return CreationResult.CreatedCounters;
            }
        }

        private void MakeThumbnail(string sourceFile, string destDir, int width, int height)
        {
            TotalImageCounter.Increment();
            ImagesPerSecondCounter.Increment();
            // image processing code goes here
        }

        //Writing 
        private static EventLog imageEventLog;
        private enum CreationResultEventLog
        {
            CreatedLog,
            LoadedLog
        };

        static CreationResultEventLog SetupLog()
        {
            string categoryName = "Image Processing";

            if (EventLog.SourceExists(categoryName))
            {
                imageEventLog = new EventLog();
                imageEventLog.Source = categoryName;
                return CreationResultEventLog.LoadedLog;
            }

            EventLog.CreateEventSource(source: categoryName, logName: categoryName + " log");
            return CreationResultEventLog.CreatedLog;
        }

        private void DisplayEventLog(string categoryName)
        {
            if (!EventLog.SourceExists(categoryName))
            {
                Console.WriteLine("Event log not present");
            }
            else
            {
                EventLog imageEventLog = new EventLog();
                imageEventLog.Source = categoryName;
                foreach (EventLogEntry entry in imageEventLog.Entries)
                {
                    Console.WriteLine("Source: {0}, Type: {1}, Time: {2}, Message: {3}", 
                        entry.Source, entry.EntryType, entry.TimeWritten, entry.Message);
                }
            }
        }


        private static void ImageEventLog_EntryWritten(object sender, EntryWrittenEventArgs e)
        {
            Console.WriteLine("Event Log Eventhandler: "+ e.Entry.Message);
        }

        public void Run()
        {
            //Binding to log events
            //A program can bind to an event log and receive notification events when the log
            //is written to.You can use this to create a dashboard that displays the activity of
            //your applications.The dashboard binds to log events that your application
            //generates. The program binds a handler to
            //the Image Processing log events and then waits for events to arrive.To see this
            //in action, run Listing 3-46 and then run Listing 3-44. You will see event
            //messages printed out as they are written into the log.
            string categoryName = "Image Processing";
            EventLog imageEventLog = new EventLog();
            imageEventLog.Source = categoryName;
            imageEventLog.EntryWritten += ImageEventLog_EntryWritten;
            imageEventLog.EnableRaisingEvents = true;

            //A program can also read from the event log.Listing 3-45 shows how this is
            //performed. The program reads the image processing event log and prints out
            //every entry in it.If the log has not been created(or none of the earlier example
            //programs have been run on the computer) the program prints a warning message and ends.
            DisplayEventLog("Image Processing");

            //We have seen that you can use EventLogTraceListener to write messages to the Windows Event Log (administrator privileges). 
            //TraceListener trace = new EventLogTraceListener();
            //The Event Log is used by Windows system components and applications to log
            //the operation of your computer. The EventLog class in the System.Diagnostics
            //can be used to add events to the event log in a similar manner to that adding
            //performance counters. As with using performance counters, an application can only write to the
            //event log if it has appropriate permissions.
            //The process of writing to an event log is very similar to that of creating and
            //updating a counter. Before a log can be written, it must be created. Then, once
            //the log has been created it can accept log events.
            //https://stackoverflow.com/questions/25725151/write-to-windows-application-event-log
            //using (EventLog eventLog = new EventLog("Application"))
            //{
            //  eventLog.Source = "Application";
            //  eventLog.WriteEntry("Log message example", EventLogEntryType.Information, 101, 1);
            //}

            //TODO EventLog.CreateEventSource created entries in: 
            //Computer\HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\EventLog\
            //But I was unable to find logged messages using the Event Viewer 
            //CreationResultEventLog creationResult = SetupLog();
            //if (creationResult == CreationResultEventLog.LoadedLog)
            //{
            //    Console.WriteLine("Event Log loaded.");
            //    imageEventLog.WriteEntry("Image processing started");
            //    // process images
            //    imageEventLog.WriteEntry("Image processing ended");
            //}
            //else
            //{
            //    Console.WriteLine("Event Log created.");
            //}
            
            //Create your own performance counters
            //You can also create your own performance counters too. These are added to the
            //performance counters on the host machine and can be accessed by other
            //programs and viewed using the Performance Monitor program.
            //The SetupPerformanceCounters method checks that the counters exist before it tries
            //to load them. If the counters don’t exist they are created.Counters are organized
            //in categories.Each counter also has a name and can be applied to one or more
            //instances.For example, the system has multiple instances of counters for each processor.
            //Once the counters have been created on a machine, they can be browsed for and viewed as any other counter.

            //You need to have administrator privileges to create and write to PerformanceCounters.
            //You can read PerformanceCounters without administrator permissions.  
            //CreationResult creationResult =  SetupPerformanceCounters();
            //The first time that the program is run it creates the counters and then ends.
            //The second time the program is run it will update the counters during image processing.
            //if (creationResult == CreationResult.LoadedCounters)
            //{
            //    Console.WriteLine("Performance counters loaded.");
            //    Console.WriteLine("Press any key to stop");
            //    for(;;)
            //    {
            //        Console.WriteLine("Processing Thumbnail. ");
            //        MakeThumbnail(null, null, 0, 0);
            //        Thread.Sleep(500);
            //        if (Console.KeyAvailable)
            //            break;
            //    }
            //}
            //else
            //{
            //    Console.WriteLine("Performance counters created.");
            //}

            //Windows maintains a large number of performance counters that can be used to
            //monitor your computer. These counters can be viewed using the Performance
            //Monitor(perfmon) tool.You can start this tool from the Windows Powershell or
            //Command prompt by issuing the command perfmon.You can read the existing
            //performance counters to enable your program to monitor the system it is running on.
            PerformanceCounter processor = new PerformanceCounter(categoryName: "Processor Information",
                counterName: "% Processor Time",
                instanceName: "_Total");
            //Prints the Processor usage 
            for (int i = 0; i < 10; i++)
            {
                Console.WriteLine("Processor time {0}", processor.NextValue());
                Thread.Sleep(500);
            }

            //Use Stopwatch class to measure elapsed time   
            //Stopwatch stopwatch = new Stopwatch();
            //stopwatch.Start();
            //sequentialTest();
            //stopwatch.Stop();
            //Console.WriteLine("Sequential time in milliseconds: {0}",
            //stopwatch.ElapsedMilliseconds);
            //stopwatch.Restart();
            //parallelTest();
            //stopwatch.Stop();
            //Console.WriteLine("Parallel loop time in milliseconds: {0}",
            //stopwatch.ElapsedMilliseconds);

            //The examples earlier show how a program can configure tracing output when it
            //runs.However, it is also possible to configure tracing output using the
            //application configuration file
            //You can configure tracing by using the configuration file for the application. If
            //you then want to change the tracing behavior of an application you just need to
            //supply a new configuration file.
            //Use SourceSwitch to control tracing
            //The SourceSwitch can be used to directly control the behavior of a TraceSource object.
            //A SourceSwitch instance is created with the name
            //control.It is then assigned to the Switch property of the TraceSource object.

            //When the application runs, it can locate this switch by name.The statement
            //next creates a TraceSource that is configured using the switch options in the config file.
            //Note that if switch information with the given name is not found in the
            //application configuration file, a trace is created that will not output any events.            
            //TraceSource trace = new TraceSource("configControl");

            TraceSource _trace = new TraceSource("Tracer", SourceLevels.All);
            SourceSwitch _control = new SourceSwitch("control", "Controls the tracing");
            TraceListener traceListener1 = new ConsoleTraceListener();
            _trace.Listeners.Add(traceListener1);
            _control.Level = SourceLevels.Information;
            _trace.Switch = _control;
            _trace.TraceEvent(TraceEventType.Start, 10000);
            _trace.TraceEvent(TraceEventType.Warning, 10001);
            _trace.TraceEvent(TraceEventType.Verbose, 10002, "At the end of the program");
            _trace.TraceData(TraceEventType.Information, 10003, new object[] { "line1", "line2" });
            _trace.Flush();
            _trace.Close();

            //Use TraceSwitch to control tracing output
            //The TraceSwitch object is provided to help manage tracing output from a
            //program.The TraceSwitch object contains a Level property that can be set to
            //determine the level of tracing output to be produced.
            //TraceSwitch instance with the name
            //control is created and set to the Warning level.This variable is then used to
            //control tracing output, first to the console, and then to the Trace class. Note that,
            //as with the levels above, the control level sets the base value for messages.In
            //other words, setting a trace level of Warning will also cause Error events to be generated.
            TraceSwitch control = new TraceSwitch("Control", "Control the trace output");
            control.Level = TraceLevel.Warning;            
            if (control.TraceError)
            {
                Console.WriteLine("TraceSwitch: An error has occurred");
            }

            if (control.TraceWarning)
            {
                Console.WriteLine("TraceSwitch: An Warning has occurred");
            }

            Trace.WriteLineIf(control.TraceWarning, "A warning message");

            //Trace using the TraceSource class
            //The Trace and Debug classes provide tracing for a program in the form of simple
            //messages.If you want to take a more managed approach to program tracing, you can use the TraceSource class.
            //An instance of the TraceSource class will create events that can be used to trace program execution.
            //The example below creates four events. The simplest event contains event type
            //information and an event number. You can also add a text string to an event, and
            //the TraceData method also allows information to be added to an event in the
            //form of a collection of object references.
            //Each event is given a particular event type and an event number.The event
            //number element of an event is just an integer value that identifies the particular
            //event. When you design the tracing in the application, you can define values that
            //will be used to represent particular events, such as events 0 to 999 can mean user
            //interface, and 1,000 to 1,999 databases, and so on.
            TraceSource trace = new TraceSource("Tracer", SourceLevels.All);
            TraceListener traceListener = new ConsoleTraceListener();
            trace.Listeners.Add(traceListener);
            trace.TraceEvent(TraceEventType.Start, 10000);
            trace.TraceEvent(TraceEventType.Warning, 10001);
            trace.TraceEvent(TraceEventType.Verbose, 10002, "At the end of the program");
            trace.TraceData(TraceEventType.Information, 1003, new object[] { "Note 1", "Message" });
            trace.Flush();
            trace.Close();            
            traceListener.Flush();
            traceListener.Close();
            traceListener.Dispose();

            //Use listeners to gather tracing information
            //By default(unless specified otherwise) the output from the Debug and Trace
            //classes is sent to the output window in Visual Studio. This will work during
            //development, but once the program has been deployed this will not be useful. A
            //program can attach listener objects to Debug and Trace, which will serve as
            //destinations for tracing information.
            //Example below shows how this is used.It attaches a ConsoleTraceListener
            //instance to the collection of listener objects that are accepting output from the
            //Trace class. When this program runs, the message produced by the Trace object
            //are also displayed on the console.
            //You can add multiple listeners to a given tracing source so that tracing
            //information can be sent to both the console, and an XML log file if you wish.To
            //stop the output of tracing information you can remove listeners from the
            //Listeners collection.You can use listeners with the Debug and the Trace classes.
            TraceListener consoleListener = new ConsoleTraceListener();
            Trace.Listeners.Add(consoleListener);
            Debug.WriteLine("Debug.WriteLine() should appear in the Console.");
            Trace.WriteLine("Starting the program"); //Starting the program
            Trace.TraceInformation("This is an information message");
            Trace.TraceWarning("This is a warning message");
            Trace.TraceError("This is an error message");
            Trace.Listeners.Remove(consoleListener);
            consoleListener.Flush();
            consoleListener.Close();
            consoleListener.Dispose();
            //There are a number of different TraceListener objects that can be created.
            //You can also create your own custom listener class based on the TraceListener class.
            //1) ConsoleTraceListener Sends the output to the console.
            //2) TextWriterTraceListener Sends the output to a given TextWriter
            //3) XMLWriterTraceListener Sends XML formatted output to an XML writer
            //4) DelimitedTextTraceListener Sends the output to a TextWriter
            //5) EventLogTraceListener Sends the output to the Event log
            //6) EventSchemaTraceListener Sends the output to an XML encoded file compliant with the Event log schema

            //Example of TextWriterTraceListener, log to file
            FileStream stream = new FileStream("TraceOutput.txt", FileMode.Create);
            TraceListener textFileListener = new TextWriterTraceListener(stream);
            Trace.Listeners.Add(textFileListener);
            Debug.WriteLine("Debug.WriteLine() should appear in the Console.");
            Trace.WriteLine("Starting the program"); //Starting the program
            Trace.TraceInformation("This is an information message");
            Trace.TraceWarning("This is a warning message");
            Trace.TraceError("This is an error message");
            Trace.Listeners.Remove(textFileListener);
            textFileListener.Flush();
            textFileListener.Close();
            textFileListener.Dispose();

            //Example of XMLWriterTraceListener, log to file, 
            //Note XML format is not correctly indented 
            FileStream xmlStream = new FileStream("Trace.xml", FileMode.Create);
            TraceListener xmlTrace = new XmlWriterTraceListener(xmlStream);
            Trace.Listeners.Add(xmlTrace);
            Debug.WriteLine("Debug.WriteLine() should appear in the Console.");
            Trace.WriteLine("Starting the program"); //Starting the program
            Trace.TraceInformation("This is an information message");
            Trace.TraceWarning("This is a warning message");
            Trace.TraceError("This is an error message");
            Trace.Listeners.Clear();
            xmlTrace.Flush();
            xmlTrace.Close();
            xmlTrace.Dispose();

            //EventLogTraceListener Sends the output to the Event log
            //You need to add nuget System.Diagnostics.EventLog;
            //You must run this application as an administrator to log To EventLog.
            //TraceListener eventLogger = new EventLogTraceListener("myEventLogSource");
            //Trace.Listeners.Add(eventLogger);
            //Debug.WriteLine("Debug.WriteLine() should appear in the Console.");
            //Trace.WriteLine("Starting the program"); //Starting the program
            //Trace.TraceInformation("This is an information message");
            //Trace.TraceWarning("This is a warning message");
            //Trace.TraceError("This is an error message");
            //Trace.Listeners.Clear();
            //eventLogger.Flush();
            //eventLogger.Close();
            //eventLogger.Dispose();

            //Use assertions in Debug and Trace
            //An assertion is a statement that you make, believing it to be true.
            //The Debug.Assert method is provided with a Boolean parameter.If
            //the parameter is true, the assertion is correct and the program continues.If the
            //parameter is false, the assertion fails and the program will display a message
            //offering the developer the option to continue the program.
            string customerName = "Customer name";
            Debug.Assert(!string.IsNullOrEmpty(customerName), "customerName is empty.");
            Trace.Assert(!string.IsNullOrEmpty(customerName), "customerName is empty.");

            //If you want to add this form of tracing output to production code you can use
            //the Trace object, which can be used in the same way as the Debug object.
            //The Trace symbol is usually defined for release code,
            // which means that these statements will produce output in production code.The
            // Trace object provides additional messages; the TraceInformation, TraceWarning,
            // and TraceError methods can be used to specify the importance of the message.
            //You can filter these messages so that, for instance, you can only see error information.
            Trace.WriteLine("Starting the program"); //Starting the program
            Trace.TraceInformation("This is an information message"); //70-483 Information: 0 : This is an information message
            Trace.TraceWarning("This is a warning message"); //70-483 Warning: 0 : This is a warning message 
            Trace.TraceError("This is an error message");//70-483 Error: 0 : This is an error message 

            int age = 2010;
            //By default, the output from the Debug statements is directed to the Output window in Visual Studio.
            //Note, that if the program is not compiled for debug, the debug statements are
            //not included in the program that is produced.The debug code uses a conditional
            //attribute to disable these methods when the debug symbol is not defined.            

            Debug.WriteLine("Run()");
            MethodA(12);
            //The WriteLineIf method can be used to write a debug message if a given condition is true.
            Debug.WriteLineIf(age == 2010, "Year is indeed 2010.");
        }

        public void MethodA(object obj)
        {
            var i = 2020;

            Debug.Indent();
            Trace.WriteLineIf(obj.GetType() == typeof(int), "Input parameter is of correct type Int.");

            Debug.WriteLine("MethodA()");
            Debug.WriteLine($"i: {i}");
            int result = MethodB();
            Debug.WriteLine($"result: {result}");
            Debug.Unindent();
        }

        public int MethodB()
        {
            string name = "Mohamed";

            Debug.Indent();
            Debug.WriteLine("MethodB()");
            Debug.WriteLine($"name: {name}");
            Debug.Unindent();
            return 2020;
        }
    }
}
