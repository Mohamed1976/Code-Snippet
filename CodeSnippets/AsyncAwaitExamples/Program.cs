using CyberSpace;
using ProgressSpace;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Net;
using System.Threading;
using System.Threading.Tasks;

namespace AsyncAwaitExamples
{
    class Program
    {
        static async Task Main(string[] args)
        {
            #region [ Tasks Async/Await  ] 

            //The use of async await makes the UI more responsive.  
            //Every async method becomes a class generated by the compiler.
            //Await every task, none-awaited tasks hide exceptions
            //Do not use MethodName().Wait(), the Wait() method, use await instead 
            //If you do not need to return to the calling thread use .ConfigureAwait(false);
            //Everything that does not touch UI code you can use .ConfigureAwait(false), 
            //when multiple awaits in method            
            Console.WriteLine($"\nTasks---------------------------------------------------------------------------------");
            List<string> urls = new List<string>(new string[] 
            { 
                "https://www.yahoo.com", 
                "https://www.google.com",
                "https://www.microsoft.com",
                "https://www.nu.nl",
                "https://stackoverflow.com",
                "https://www.codeproject.com"
            });

            //Pass cancellationToken to method 
            CancellationTokenSource cts = new CancellationTokenSource();
            //Call cts.Cancel(); to cancel task
            try
            {
                await DownloadWebpages(urls, cts.Token);

            }
            catch (OperationCanceledException ex)
            {
                Console.WriteLine($"{Environment.NewLine} {ex.Message}");
            }

            await DownloadWebpages2(urls);
            await DownloadWebpagesParallel(urls);

            //Create several Tasks and await them all. 
            List<Task<WebsiteDataModel>> tasks = new List<Task<WebsiteDataModel>>();
            foreach(string url in urls)
            {
                tasks.Add(DownloadWebpagesParallel2(url));
            }
            var results = await Task.WhenAll(tasks);
            foreach (WebsiteDataModel website in results)
            {
                Console.WriteLine($"Webpage download parallel Version 2, url: {website.Url}, size: {website.Size}, elapsed time, {website.RetrieveTime}ms");
            }

            //Called method returns immediately a task   
            List<Task<string>> getWebpageTasks = new List<Task<string>>();
            foreach (string url in urls)
            {
                getWebpageTasks.Add(DownloadWebpagesTask(url));
            }
            var downloads = await Task.WhenAll(getWebpageTasks);
            foreach (string download in downloads)
            {
                Console.WriteLine($"Webpage download Tasks, size: {download.Length}");
            }

            //Using IAsyncEnumerable containing Tuple as return type.
            //ReportProgress handler is passed to the async method. 
            //When progress.Report is called, the callback Progress_ProgressChanged is then called
            Progress<ProgressReportModel> progress = new Progress<ProgressReportModel>();
            progress.ProgressChanged += Progress_ProgressChanged;
            await foreach (var webpage in DownloadWebpagesIAsyncEnumerable(urls.ToArray(), progress))
            {
                Console.WriteLine($"Download using IAsyncEnumerable, url{webpage.Url}, length:{webpage.Size}, elapsed time{webpage.DeltaTime}");
            }

            await ParallelForEachDowload(urls.ToArray());

            #endregion

            Console.ReadLine();
        }

        //The fastest downloaded website is printed first 
        public static async Task ParallelForEachDowload(string[] urls)
        {
            await Task.Run(() =>
            {
                Parallel.ForEach<string>(urls, (url) =>
                {
                    var stopwatch = Stopwatch.StartNew();
                    WebClient webClient = new WebClient();
                    string content = webClient.DownloadString(url);
                    var elapsed = stopwatch.ElapsedMilliseconds;
                    Console.WriteLine($"ParallelForEachDowload: {url}, size: {content.Length}, elapsed time, {elapsed}ms");
                });
            });
        }

        private static void Progress_ProgressChanged(object sender, ProgressReportModel e)
        {
            Console.WriteLine($"Progress Changed {e.PercentageComplete}");
            foreach(string url in e.SitesDownloaded)
            {
                Console.WriteLine($"\t {url}");
            }
        }

        public static async Task DownloadWebpages(List<string> urls, CancellationToken cancellationToken)
        {
            //Start timer and download webpages async  
            foreach (string url in urls)
            {
                var stopwatch = Stopwatch.StartNew();
                WebClient webClient = new WebClient();
                string content = await webClient.DownloadStringTaskAsync(url);
                var elapsed = stopwatch.ElapsedMilliseconds;
                Console.WriteLine($"Webpage download: {url}, size: {content.Length}, elapsed time, {elapsed}ms");
                cancellationToken.ThrowIfCancellationRequested();
                //Or you can check cancellationToken.IsCancellationRequested bool to abort operation
            }
        }

        //Making a synchronous method asynchronous using Task.Run  
        public static async Task DownloadWebpages2(List<string> urls)
        {
            foreach (string url in urls)
            {
                var stopwatch = Stopwatch.StartNew();
                WebClient webClient = new WebClient();
                string content = await Task.Run(() => webClient.DownloadString(url));
                //The above call can also be code as below
                //string content = await Task.Run(() =>
                //{
                //    return webClient.DownloadString(url);
                //});
                var elapsed = stopwatch.ElapsedMilliseconds;
                Console.WriteLine($"Webpage download Version 2: {url}, size: {content.Length}, elapsed time, {elapsed}ms");
            }
        }

        public static async Task DownloadWebpagesParallel(List<string> urls)
        {
            //Create task list in which each task returns a tuple  
            List<Task<(string Url, string Content)>> tasks = new List<Task<(string,string)>>();
            foreach (string url in urls)
            {
                tasks.Add(Task.Run(() =>
                {
                    WebClient webClient = new WebClient();
                    string content = webClient.DownloadString(url);
                    return (url, content);
                    //You can also use statement below 
                    //return (url, webClient.DownloadString(url));
                }));
            }

            var stopwatch = Stopwatch.StartNew();
            var results = await Task.WhenAll(tasks);
            var elapsed = stopwatch.ElapsedMilliseconds;
            foreach(var result in results)
            {
                Console.WriteLine($"Webpage download parallel: {result.Url}, size: {result.Content.Length}, TOTAL elapsed time, {elapsed}ms");
            }
        }

        public static async Task<WebsiteDataModel> DownloadWebpagesParallel2(string url)
        {
            WebClient webClient = new WebClient();
            var stopwatch = Stopwatch.StartNew();
            string content = await webClient.DownloadStringTaskAsync(url);
            var elapsed = stopwatch.ElapsedMilliseconds;
            return new WebsiteDataModel(url, content, content.Length, elapsed);
        }

        public static Task<string> DownloadWebpagesTask(string url)
        {
            WebClient webClient = new WebClient();
            return webClient.DownloadStringTaskAsync(url);
        }

        internal static async IAsyncEnumerable<(string Content, string Url, long Size, long DeltaTime)> DownloadWebpagesIAsyncEnumerable(string[] urls, IProgress<ProgressReportModel> progress)
        {
            ProgressReportModel progressReport = new ProgressReportModel(); 

            foreach (string url in urls)
            {
                var stopwatch = Stopwatch.StartNew();
                WebClient webClient = new WebClient();
                string content = await webClient.DownloadStringTaskAsync(url);
                var elapsed = stopwatch.ElapsedMilliseconds;
                //Update current progress
                progressReport.SitesDownloaded.Add(url);
                progressReport.PercentageComplete = progressReport.SitesDownloaded.Count * 100 / urls.Length;
                progress.Report(progressReport);
                yield return (content, url, content.Length, elapsed);
            }
        }
    }
}

namespace ProgressSpace
{
    public class ProgressReportModel
    {
        public ProgressReportModel()
        {
        }

        public int PercentageComplete { get; set; } = 0;
        public List<string> SitesDownloaded { get; set; } = new List<string>();
    }
}

namespace CyberSpace
{
    public class WebsiteDataModel
    {
        public WebsiteDataModel(string url, string content, long size, long retrieveTime)
        {
            Url = url;
            Size = size;
            Content = content;
            RetrieveTime = retrieveTime;
        }

        public long RetrieveTime { get; private set; }
        public string Url { get; private set; }
        public long Size { get; private set; }
        public string Content { get; private set; }
    }
}