//#define DEBUG
//#undef DEBUG
//#define TRACE

using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Configuration;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

//Note that, as with security, diagnostics support should be “designed in” to an
//application at the start of the development.

//By default (unless specified otherwise) the output from the Debug and Trace
//classes is sent to the output window in Visual Studio.
//program can attach listener objects to Debug and Trace, which will serve as
//destinations for tracing information.

//You can also use information generated by logging and tracing to investigate
//performance issues with systems out in the field.If is very useful to be able to
//determine the loading levels and the nature of transactions being performed on
//the customer site. You use logging to find out what your program is doing and what happened
//when it failed.You use tracing to discover the path followed by the program to
//perform a particular action.

namespace _70_483_USING_NET_FRAMEWORK.Exercises
{
    public class Diagnostics
    {
        public Diagnostics()
        {
        }

        private void EventLog1_EntryWritten(object sender, EntryWrittenEventArgs e)
        {
            Console.WriteLine("Callback: Time: {0}, Message: {1}", e.Entry.TimeWritten, e.Entry.Message);
        }

        public void Run()
        {
            const string categoryNameEventLog = "Demo Processing";
            //-----------------------------------------------------------------------------------
            //You can subscribe to events of EventLog when message is written
            //A program can bind to an event log and receive notification events when the log
            //is written to.You can use this to create a dashboard that displays the activity of
            //your applications.The dashboard binds to log events that your application generates. 
            //-----------------------------------------------------------------------------------
            if(EventLog.SourceExists(categoryNameEventLog))
            {
                EventLog eventLog1 = new EventLog();
                eventLog1.Source = categoryNameEventLog;
                eventLog1.EntryWritten += EventLog1_EntryWritten;
                eventLog1.EnableRaisingEvents = true;
                Thread.Sleep(500);
                eventLog1.WriteEntry("Information message", EventLogEntryType.Information, 102, 2);
                eventLog1.WriteEntry("An error occurred", EventLogEntryType.Error, 1001, 3);                
                eventLog1.EntryWritten -= EventLog1_EntryWritten;
            }

            //-----------------------------------------------------------------------------------
            //A program can also read from the event log.
            //-----------------------------------------------------------------------------------
            if (EventLog.SourceExists(categoryNameEventLog))
            {
                //Print messages from EventLog 
                EventLog eventLog1 = new EventLog();
                eventLog1.Source = categoryNameEventLog;
                foreach (EventLogEntry eventLogEntry in eventLog1.Entries)
                    Console.WriteLine("Time: {0}, Message: {1}, Type: {2}", 
                        eventLogEntry.TimeWritten, eventLogEntry.Message, eventLogEntry.EntryType);
            }

            //-----------------------------------------------------------------------------------
            //It is also possible to send tracing output to the Windows Event Log.
            //The Event Log is used by Windows system components and applications to log
            //the operation of your computer. The EventLog class in the System.Diagnostics
            //can be used to add events to the event log in a similar manner to that adding
            //performance counters. As with using performance counters, an application can 
            //only write to the event log if it has appropriate permissions.
            //The process of writing to an event log is very similar to that of creating and
            //updating a counter. Before a log can be written, it must be created. Then, once
            //the log has been created it can accept log events.
            //-----------------------------------------------------------------------------------            

            try
            {
                //Note after creation of EventLog, you need to close and reopen event viewer to see the created
                //new EventLog 
                if (!EventLog.SourceExists(categoryNameEventLog))
                {
                    Console.WriteLine("Creating EventLog: {0}", categoryNameEventLog);
                    EventLog.CreateEventSource(source: categoryNameEventLog, logName: categoryNameEventLog + " log");
                    Console.WriteLine("EventLog: {0} Created successfully", categoryNameEventLog);
                    Thread.Sleep(1000);
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine("Error occurred while creating EventLog: {0}", ex.Message);
                throw;
            }

            if(EventLog.SourceExists(categoryNameEventLog))
            {
                EventLog eventLog1 = new EventLog();
                eventLog1.Source = categoryNameEventLog;
                eventLog1.WriteEntry("Start processing data.", EventLogEntryType.Information, 101, 1);
                eventLog1.WriteEntry("Demo: Error occured while contacting database", EventLogEntryType.Error,102,2);
                Console.WriteLine("Finished writting to Eventlog");
            }
            
            //You can also create your own performance counters too.These are added to the
            //performance counters on the host machine and can be accessed by other
            //programs and viewed using the Performance Monitor program.
            //Counters are organized in categories. Each counter also has a name and can be applied to one or more
            //instances. For example, the system has multiple instances of counters for each processor.
            PerformanceCounter TotalImageCounter;
            PerformanceCounter ImagesPerSecondCounter;
            string categoryName = "Demo Processing";

            //Note that for a program to create performance monitors, it must be running
            //with Administrator privileges.
            if (!PerformanceCounterCategory.Exists(categoryName))
            {
                //There are a number of different types of counter that can be created.The
                //program above uses two types of counter. The counter that counts the number of
                //images processed is the NumberOfItems64 type, which counts using a 64 bit
                //integer.The counter that counts the number of images being processed per
                //second is a RateOfCountsPerSecond32 that averages the number of updates per
                //second to the counter.

                CounterCreationData[] counters = new CounterCreationData[]
                {
                    new CounterCreationData(counterName:"# of images processed",
                                counterHelp:"number of images resized",
                                counterType:PerformanceCounterType.NumberOfItems64),

                    new CounterCreationData(counterName: "# images processed per second",
                                counterHelp:"number of images processed per second",
                                counterType:PerformanceCounterType.RateOfCountsPerSecond32)
                };

                CounterCreationDataCollection counterCollection = new CounterCreationDataCollection(counters);

                PerformanceCounterCategory.Create(categoryName: categoryName,
                    categoryHelp: "Image processing information",
                    categoryType: PerformanceCounterCategoryType.SingleInstance,
                    counterData: counterCollection);

                Console.WriteLine("Demo performance counters created.");
                Thread.Sleep(1000);
            }

            if (PerformanceCounterCategory.Exists(categoryName))
            {
                Console.WriteLine("PerformanceCounterCategory.Exists(categoryName)");
                // production code should use using
                TotalImageCounter = new PerformanceCounter(
                    categoryName: categoryName,
                    counterName: "# of images processed",
                    readOnly: false);

                ImagesPerSecondCounter = new PerformanceCounter(
                    categoryName: categoryName,
                    counterName: "# images processed per second",
                    readOnly: false);

                Console.WriteLine("Demo performance counters Loaded.");

                //Once the counters have been created on a machine, they can be browsed for
                //and viewed as any other counter. They can for example be monitored using perfmon 
                Console.WriteLine("Press any key to stop monitoring.");
                for (; ; )
                {
                    TotalImageCounter.Increment();
                    ImagesPerSecondCounter.Increment();
                    Thread.Sleep(500);
                    Console.WriteLine("ImageCounter: {0:N2}, ImagesPerSecondCounter: {1}", 
                        TotalImageCounter.NextValue(),
                        ImagesPerSecondCounter.NextValue());
                    if (Console.KeyAvailable)
                        break;
                }
            }

            //-----------------------------------------------------------------------------------
            //Windows maintains a large number of performance counters that can be used to
            //monitor your computer. These counters can be viewed using the Performance
            //Monitor(perfmon) tool.
            //A program can read the values of the performance counters so that it can monitor
            //the system in which it is running.A given performance counter is identified by
            //its category name, counter name and instance name.
            //-----------------------------------------------------------------------------------
            //Example on how to monitor Processor Time
            PerformanceCounter performanceCounter = new PerformanceCounter(
                categoryName: "Processor Information",
                counterName: "% Processor Time",
                instanceName: "_Total");

            Console.WriteLine("Press any Key to stop.");
            
            for(;;)
            {
                Console.WriteLine("{0:N2}", performanceCounter.NextValue());
                Thread.Sleep(500);
                if (Console.KeyAvailable)
                    break;
            }

            //-----------------------------------------------------------------------------------
            //The Diagnostics display in Visual Studio gives a very good overview of the
            //performance of an application.
            //If you require more detail than you can get from the Diagnostic Tools, Visual
            //Studio 2017 contains powerful profiling tools that you can use to discover where
            //your application is spending most of its time.Once you know this, you can focus
            //on optimizing that particular method. 
            //The profiling tools can be found using ALT+F2
            //
            // Diagnostic Tools in Visual Studio 
            // Powerful profiling tool ALT+F2
            //-----------------------------------------------------------------------------------

            //-----------------------------------------------------------------------------------
            //Example on how to use StopWatch class 
            //-----------------------------------------------------------------------------------
            //for(;;)
            //{
            Stopwatch stopwatch = new Stopwatch();
            stopwatch.Start();
            Thread.Sleep(250);
            stopwatch.Stop();
            Console.WriteLine("Elapsed time: {0}(ms)", stopwatch.ElapsedMilliseconds);
            stopwatch.Restart();
            Thread.Sleep(250);
            stopwatch.Stop();
            Console.WriteLine("Elapsed time: {0}(ms)", stopwatch.ElapsedMilliseconds);
            //}

            //-----------------------------------------------------------------------------------
            //Writing to Eventlog, you need administrator privileges 
            //-----------------------------------------------------------------------------------
            //You have already seen how an application can write tracing information to an
            //output file.It is also possible to send tracing output to the Windows Event Log.
            //The Event Log is used by Windows system components and applications to log
            //the operation of your computer. The EventLog class in the System.Diagnostics
            //can be used to add events to the event log in a similar manner to that adding
            //performance counters. As with using performance counters, an application 
            //can only write to the event log if it has appropriate permissions.
            //The process of writing to an event log is very similar to that of creating and
            //updating a counter. Before a log can be written, it must be created. Then, once
            //the log has been created it can accept log events.
            EventLog eventLog = new EventLog();
            //Name of the eventlog you wish to write to.
            //You can create a new eventlog using EventLog.CreateEventSource
            eventLog.Source = "Application";
            eventLog.WriteEntry("Message to eventlog", EventLogEntryType.Error, 100);

            //-----------------------------------------------------------------------------------
            //Configuring TraceSource and SourceSwitch using config file 
            //You can add more complex behaviors to the configuration file, including the
            //creation and assignment of listeners to TraceSource objects.You can also apply
            //filters to listeners, so that a given listener will only receive particular levels of
            //tracing information.This gives you a lot of flexibility in the tracing and logging
            //that your application can perform.
            //-----------------------------------------------------------------------------------
            //Create Trace source, name matches config file. 
            TraceSource traceSource1 = new TraceSource("DemoSource");
            traceSource1.TraceEvent(TraceEventType.Warning, 1001, "#Warning message.");
            traceSource1.TraceEvent(TraceEventType.Error, 1002, "#Error message.");
            traceSource1.TraceEvent(TraceEventType.Verbose, 101, "#Verbose message.");
            //You can write to any specific listener
            traceSource1.Listeners["Console"].WriteLine("Message to Console listner.", "General messages");
            traceSource1.Listeners["xmlListener"].WriteLine("Message to xml file.", "General messages");
            traceSource1.Flush();

            //-----------------------------------------------------------------------------------
            // Example of TraceSource and SourceSwitch 
            //-----------------------------------------------------------------------------------
            TraceSource traceSource = new TraceSource("Tracer");
            ConsoleTraceListener consoleTraceListener3 = new ConsoleTraceListener();
            XmlWriterTraceListener xmlWriterTraceListener1 = new XmlWriterTraceListener("myTracer.xml");
            SourceSwitch sourceSwitch = new SourceSwitch("Source switcher");
            sourceSwitch.Level = SourceLevels.All;
            traceSource.Switch = sourceSwitch;
            int index = traceSource.Listeners.Add(consoleTraceListener3);
            traceSource.Listeners[index].Name = "Console";
            index = traceSource.Listeners.Add(xmlWriterTraceListener1);
            traceSource.Listeners[index].Name = "Xml writer";

            //Logging
            traceSource.TraceEvent(TraceEventType.Verbose, 1001, "Verbose message");
            traceSource.TraceEvent(TraceEventType.Warning, 1002, "Warning message");
            traceSource.Flush();
            
            //-----------------------------------------------------------------------------------
            //It is also possible to configure tracing output using the
            //application configuration file You can configure tracing by 
            //using the configuration file for the application. If
            //you then want to change the tracing behavior of an application 
            //you just need to supply a new configuration file.
            //The code below shows how a switch should be set
            //up in a config file.A switch with the name configControl 
            //is created that will cause all tracing events to be produced.
            //When the application runs, it can locate this switch by name.The statement
            //next creates a TraceSource that is configured using the switch options in the
            //config file. Note that if switch information with the given name is not found in the
            //application configuration file, a trace is created that will not output any events.
            //-----------------------------------------------------------------------------------
            //"configControl" name in Config file controls trace level 
            TraceSource trace1 = new TraceSource("configControl"); 
            ConsoleTraceListener consoleTraceListener2 = new ConsoleTraceListener();
            trace1.Listeners.Add(consoleTraceListener2);
            trace1.TraceEvent(TraceEventType.Verbose, 1001, "Verbose message.");
            trace1.TraceEvent(TraceEventType.Information, 1002, "Information message.");
            trace1.TraceData(TraceEventType.Warning, 1003, new object[] { "Message in a bottle 1", "Another message" });
            trace1.TraceData(TraceEventType.Error, 1004, "Error message.");
            trace1.TraceData(TraceEventType.Critical,1005, "Critical message.");
           
            //-----------------------------------------------------------------------------------
            // TraceSwitch
            //
            //A TraceSwitch instance with the name control is created and set to the Warning level.
            //This variable is then used to control tracing output, first to the console, 
            //and then to the Trace class. Note that, as with the levels above, the control 
            //level sets the base value for messages.In other words, setting a trace level of 
            //Warning will also cause Error events to be generated.
            //
            //-----------------------------------------------------------------------------------
            TraceSwitch traceSwitch = new TraceSwitch("Tracer", "Logging activator");
            traceSwitch.Level = TraceLevel.Error;

            if (traceSwitch.TraceVerbose)
            {
                Console.WriteLine("Verbose message.");
            }

            if (traceSwitch.TraceInfo)
            {
                Console.WriteLine("Informational message.");
            }

            if(traceSwitch.TraceError)
            {
                Console.WriteLine("Error message.");
            }

            Trace.WriteLineIf(traceSwitch.TraceInfo, "Another informational message.");

            //-----------------------------------------------------------------------------------
            //TraceSource
            //-----------------------------------------------------------------------------------
            //If you want to take a more managed approach to program tracing, you
            //can use the TraceSource class. An instance of the TraceSource class will create
            //events that can be used to trace program execution.
            //The code below creates  events. The simplest event contains event type
            //information and an event number. You can also add a text string to an event, and
            //the TraceData method also allows information to be added to an event in the
            //form of a collection of object references.
            //Each event is given a particular event type and an event number.The event
            //number element of an event is just an integer value that identifies the particular
            //event. When you design the tracing in the application, you can define values that
            //will be used to represent particular events, such as events 0 to 999 can mean user
            //interface, and 1,000 to 1,999 databases, and so on.
            //There are a range of event types that are specified by a value of type
            //TraceEventType.The event types, in increasing order of significance, are as follows:            
            TraceSource trace = new TraceSource("My Tracer", SourceLevels.All);

            //The SourceSwitch can be used to directly control the behavior of a TraceSource
            //object. It works in the same way as the TraceSwitch described. 
            //A SourceSwitch instance is created with the name control.
            //It is then assigned to the Switch property of the TraceSource object.
            SourceSwitch control = new SourceSwitch("control", "Controls the tracing");
            control.Level = SourceLevels.Error;
            trace.Switch = control;
            
            //Unless you specify otherwise, the events are delivered to the Output window
            //in Visual Studio, but you can also add a TraceListener as for the Debug andTrace classes.
            ConsoleTraceListener consoleTraceListener1 = new ConsoleTraceListener();
            trace.Listeners.Add(consoleTraceListener1);
            trace.TraceEvent(TraceEventType.Start, 10000);
            trace.TraceEvent(TraceEventType.Warning, 10001);
            trace.TraceEvent(TraceEventType.Verbose, 10002, "At the end of the program");
            trace.TraceData(TraceEventType.Information, 1003, new object[] { "Note 1", "Message 1" });
            trace.TraceData(TraceEventType.Error, 2020, new object[] { "Error 1", "Error 2" });
            trace.TraceData(TraceEventType.Critical, 205011, new object[] { "Critical Error 1", "Critical Error 2" });
            trace.TraceInformation("Trace Information.");
            
            trace.TraceData(TraceEventType.Verbose, 1000, "Verbose message should NOT be displayed.");
            trace.TraceData(TraceEventType.Warning, 1001, "Warning message should be displayed.");
            trace.TraceData(TraceEventType.Error, 1002, "Error message should be displayed.");

            trace.Flush();
            trace.Close();

            //-----------------------------------------------------------------------------------
            // ConfigurationManager.AppSettings
            //
            //https://docs.microsoft.com/en-us/dotnet/api/system.configuration.configurationmanager.appsettings?view=netframework-4.8
            //-----------------------------------------------------------------------------------
            ReadAllSettings();

            //-----------------------------------------------------------------------------------
            // Use ConsoleTraceListner to log messages
            //-----------------------------------------------------------------------------------
            //You can add multiple listeners to a given tracing source so that tracing
            //information can be sent to both the console, and an XML log file if you wish. To
            //stop the output of tracing information you can remove listeners from the
            //Listeners collection. You can use listeners with the Debug and the Trace classes.
            ConsoleTraceListener consoleTraceListener = new ConsoleTraceListener();
            Trace.Listeners.Add(consoleTraceListener);

            XmlWriterTraceListener xmlWriterTraceListener = new XmlWriterTraceListener(@".\xmlWriter.xml");
            Trace.Listeners.Add(xmlWriterTraceListener);

            TextWriterTraceListener textWriterTraceListener = new TextWriterTraceListener(@".\TextWriter.txt");
            Trace.Listeners.Add(textWriterTraceListener);

            DelimitedListTraceListener delimitedListTraceListener = new DelimitedListTraceListener("delimitedOutput.csv");
            Trace.Listeners.Add(delimitedListTraceListener);

            EventSchemaTraceListener eventSchemaTraceListener = new EventSchemaTraceListener(@".\EventSchema.log");
            Trace.Listeners.Add(eventSchemaTraceListener);

            //-----------------------------------------------------------------------------------
            // Use XmlWriterTraceListner to write to file
            //-----------------------------------------------------------------------------------
            //using (XmlWriterTraceListener xmlWriterTraceListener = new XmlWriterTraceListener(@".\xmlWriter.xml"))
            //{
            //    xmlWriterTraceListener.WriteLine("Message written to XmlWriterTraceListener.");
            //    //xmlWriterTraceListener.Flush();
            //    //xmlWriterTraceListener.Close();
            //}

            //using (TextWriterTraceListener textWriterTraceListener = new TextWriterTraceListener(@".\TextWriter.txt"))
            //{
            //    textWriterTraceListener.WriteLine("Message written to TextWriterTraceListener.");
            //    //textWriterTraceListener.Flush();
            //    //textWriterTraceListener.Close();
            //}

            //using (DelimitedListTraceListener delimitedListTraceListener =
            //    new DelimitedListTraceListener("delimitedOutput.csv"))
            //{
            //    delimitedListTraceListener.WriteLine("Message written to DelimitedListTraceListener.");
            //}

            //using(EventSchemaTraceListener eventSchemaTraceListener = new EventSchemaTraceListener(@".\EventSchema.log"))
            //{
            //    eventSchemaTraceListener.WriteLine("Message written to EventSchemaTraceListener.");
            //}

            //you need administrator privileges
            //using (EventLogTraceListener eventLogTraceListener = new EventLogTraceListener("Application"))
            //{
            //    eventLogTraceListener.WriteLine("Message written to EventLogTraceListener.");
            //}

            //using (EventLogTraceListener eventLogTraceListener = new EventLogTraceListener("System"))
            //{
            //    eventLogTraceListener.WriteLine("Message written to System.");
            //}

            //Note, that if the program is not compiled for debug, the debug statements are
            //not included in the program that is produced.The debug code uses a conditional
            //attribute(see the section “Manage method execution with the Conditional
            //attribute,” in Skill 3.4) to disable these methods when the debug symbol is not defined.
            //The System.Diagnostics namespace contains Debug and Trace classes that can
            //be used to trace execution of a program.
            Debug.WriteLine("Debug: Starting the program");
            Debug.Indent();
            Debug.WriteLine("Debug: Inside a function");
            Debug.Unindent();
            Debug.WriteLine("Debug: Outside a function");
            string customerName = "Rob";
            Debug.WriteLineIf(string.IsNullOrEmpty(customerName), "The name is empty");
            Debug.Assert(!string.IsNullOrEmpty(customerName), "Name cannot be empty.");

            //The Trace symbol is usually defined for release code,
            //which means that these statements will produce output in production code.The
            //Trace object provides additional messages; the TraceInformation, TraceWarning,
            //and TraceError methods can be used to specify the importance of the message.
            Trace.WriteLine("Trace: Starting the program");
            Trace.Indent();
            Trace.WriteLine("Trace: Inside a function");
            Trace.Unindent();
            Trace.WriteLine("Trace: Outside a function");
            Trace.WriteLineIf(string.IsNullOrEmpty(customerName), "The name is empty");
            Trace.Assert(!string.IsNullOrEmpty(customerName), "Name cannot be empty.");
            Trace.WriteLine("Starting the program");
            Trace.TraceInformation("This is an information message");
            Trace.TraceWarning("This is a warning message");
            Trace.TraceError("This is an error message");

            xmlWriterTraceListener.Flush();
            textWriterTraceListener.Flush();
            delimitedListTraceListener.Flush();
            eventSchemaTraceListener.Flush();

            xmlWriterTraceListener.Close();
            textWriterTraceListener.Close();
            delimitedListTraceListener.Close();
            eventSchemaTraceListener.Close();
        }

        private void ReadAllSettings()
        {
            NameValueCollection appSettings = ConfigurationManager.AppSettings;
            if(appSettings.Count > 0)
            {
                foreach (string key in appSettings.AllKeys)
                {
                    Console.WriteLine("Key: {0} Value: {1}", key, appSettings[key]);
                }
            }
            else
            {
                Console.WriteLine("AppSettings is empty.");
            }        
        }

    }
}
