using System;
using System.Collections.Generic;
using System.Dynamic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

//With LINQ, the querying APIs are unified. That means, either it's querying collections, 
//XML elements, or data sources, we can always:
//use Where to filter the elements
//use Select to transform the value
//use Max and Min to find the maximal and minimal value
//use Sum, Count, Average to get the statistic value
//use Intersection, Except, Union to do collection operations
//use GroupBy, OrderBy, Join to do advanced queries

//Around 85% lambda expressions appear in LINQ queries, and the other 15% appear 
//in the Task Parallel Library (TPL) programming.
//public delegate TResult Func<in T, out TResult>(T arg);

namespace _70_483_USING_NET_FRAMEWORK.Exercises
{
    public class LinqExercises
    {

        private List<Magazine> magazines = new List<Magazine>()
        {
            new Magazine() { ID=1, Author="Author_1", Name="Book_1", Price=19.99m },
            new Magazine() { ID=2, Author="Author_2", Name="Book_2", Price=29.99m },
            new Magazine() { ID=3, Author="Author_3", Name="Book_3", Price=39.99m },
            new Magazine() { ID=4, Author="Author_4", Name="Book_4", Price=49.99m },
            new Magazine() { ID=5, Author="Author_5", Name="Book_5", Price=59.99m },
            new Magazine() { ID=6, Author="Author_6", Name="Book_6", Price=69.99m },
            new Magazine() { ID=7, Author="Author_7", Name="Book_7", Price=79.99m },
            new Magazine() { ID=8, Author="Author_8", Name="Book_8", Price=89.99m },
            new Magazine() { ID=9, Author="Author_9", Name="Book_9", Price=99.99m },
        };

        private void PrintEmail(dynamic email)
        {
            Console.WriteLine($"sender: {email.sender}, " +
                $"subject: {email.subject}, age: {email.age}");
        }

        public void Run()
        {
            dynamic email = new { sender = "John", subject = "subject1", age = 29 };

            var email1 = new { sender = "Wolf", subject = "subject2", age = 31 };

            dynamic email2 = new ExpandoObject();
            email2.sender = "Fox";
            email2.subject = "subject3";
            email2.age = 45;

            PrintEmail(email);
            PrintEmail(email1);
            PrintEmail(email2);

            return;
            //Concatenation Operations
            //Concatenation refers to the operation of appending one collection to another. 
            //There is only one operator Concat in this group. If you are familiar with the 
            //List<T> class, the Concat method's function is similar to the AddRange method.
            //As we see, the Concat just appends the second collection to the first collection, 
            //and it won't remove the duplicated elements. While the Union operator we learned 
            //about in the previous topic will merge the two collections and generate a set 
            //without duplicated elements.
            int[] array1 = { 1, 2, 3, 4, 5 };
            int[] array2 = { 3, 4, 5, 6, 7 };

            var concatResult = array1.Concat(array2); // 1,2,3,4,5,3,4,5,6,7
            var unionResult1 = array1.Union(array2); // 1,2,3,4,5,6,7

            System.Console.WriteLine($"Concat: {string.Join(",", concatResult)}");
            System.Console.WriteLine($"Union: {string.Join(",", unionResult1)}");

            //Set operations in LINQ refer to query operations that produce a result set that is 
            //based on the presence or absence of equivalent elements within the same or separate collections.
            //Most important, the result collection generated by the operators in this group is a set, 
            //which means there won't be duplicate elements in the result collection.
            //There are four LINQ operators in this group:
            //Distinct - Keeps unique elements of the collection and removes duplicate elements
            //Intersect - Returns the set intersection, which means elements that appear in each of two collections
            //Except - Returns the set difference, which means the elements of one collection that do not appear in a second collection
            //Union - Returns the set union, which means unique elements that appear in either of two collections
            //All these four operators do not have query expression (SQL-like) keywords.
            //All these four operators can accept an extra IEqualityComparer<TSource> type parameter. 
            //We can use this parameter to override the default equality comparison logic
            int[] left = { 1, 1, 2, 3, 3, 4, 4 };
            int[] right = { 3, 4, 5, 6 };

            var distinctResult = left.Distinct();
            var intersectResult = left.Intersect(right);
            var exceptResult = left.Except(right);
            var unionResult = left.Union(right);

            Console.WriteLine($"Distinct: {string.Join(",", distinctResult)}"); // 1, 2, 3, 4
            Console.WriteLine($"Intersect: {string.Join(",", intersectResult)}"); // 3, 4
            Console.WriteLine($"Except: {string.Join(",", exceptResult)}"); // 1, 2
            Console.WriteLine($"Union: {string.Join(",", unionResult)}"); // 1, 2, 3, 4, 5, 6

            //The Contains Operator
            //The Contains operator determines whether a collection contains a specified element.
            //note that the Contains operator gets the result value by comparing the equality of objects. 
            //That's why the output of the code below is False:
            int[] integers = { 100, 200, 300, 400, 500 };
            string[] strings = { "Tim", "Tom", "Rina", "Andrew" };
            var result3 = integers.Contains(200);
            var result4 = strings.Contains("Tim");
            System.Console.WriteLine($"{result3} {result4}");
            
            //The All Operator
            //The All operator determines whether all the elements in a collection satisfy a condition.
            //var result = records.All(r => r.Name.Length > 3);

            //The Any Operator
            //In contrast to the All operator, the Any operator determines whether there is at least 
            //one element in the source collection thet satisfies the condition. The condition is 
            //also a Func<TSource, bool> type parameter.
            //var result = records.Any(r => r.Name.Length > 15);

            //Select ALL correct options tha can calculate the volume of a cylinder
            //double CylinderVolume(double h, double r) { return Math.PI * r * r * h;} 
            //Func<double, double, double> func = (double h, double r) => { return Math.PI * r * r * h; }; 
            //Func<double, double, double> func = (h, r) => { return Math.PI * r * r * h; }; 

            //As we know, the Object class is the direct/indirect base class of all types in the 
            //C# type system. So, the code var objects = new Object[] { 1, 10L, 1.1, 1.1f, "Hello", 2, 3 }; 
            //is valid. But the elements in this Object[] have different types. The code var result = 
            //objects.OfType<int>(); helps us pick out all int type instances, they are 1, 2, and 3. 
            //(Note: 10L is long type, 1.1 is double, 1.1f is float type).
            var objects = new Object[] { 1, 10L, 1.1, 1.1f, "Hello", 2, 3 };
            IEnumerable<int> intResults = objects.OfType<int>();
            foreach (var item in intResults)
            {
                System.Console.WriteLine(item);
            }

            //Action delegate always reference the method don't have return value
            //Func delegate always reference the methods have return value
            Action show = () => { Console.WriteLine("Message shown."); };
            Func<string> getMsg = () => { return "Message returned.";  };

            Console.WriteLine(getMsg());
            show();
            
            IEnumerable<string> summaries = magazines.Select(x => $"{x.Author}\t{x.Price.ToString("C")}");
            //IEnumerable<string> summaries = magazines.Select(x => string.Format("{0}, {1:C}", x.Author, x.Price));
            foreach (string summary in summaries)
                Console.WriteLine(summary);
            
            Action<int, int, int> _sum = (x, y, z) =>
            {
                Console.WriteLine(x + y + z);
            };
            
            Console.Write($"Sum of 11 + 22 + 33 = ");
            _sum(11, 22, 33);
            
            Func<string, int, string> strHead = (str, len) => str.Substring(0, len);
            System.Console.WriteLine(strHead("Timothy", 3));

            Console.WriteLine(1987.78d.FormatWith("Player earned {0} bitcoins."));
            int[] values = { 100, 200, 300, 400, 500, 600, 700, 800, 900, 1000 };
            Console.WriteLine("Max: {0}", values.Max());
            Console.WriteLine("Min: {0}", values.Min());
            Console.WriteLine("Values implements IEnumerable<int>: {0}", values is IEnumerable<int>);

            Writer writer = new Writer()
            {
                Name = "Timothy",
                Scope = ".NET Core",
                YearsOfExperience = 15
            };

            Teacher teacher = new Teacher()
            {
                Name = "Donald",
                Scope = "JavaScript",
                YearsOfExperience = 9
            };

            writer.Introduce1();
            writer.Introduce2();
            writer.Introduce3();

            teacher.Introduce1();
            teacher.Introduce2();
            teacher.Introduce3();

            new Writer()
            {
                Name = "Wolf",
                Scope = "C++",
                YearsOfExperience = 17
            }.Introduce4().Introduce5().Introduce6();


            //Extension methods enable you to “attach” methods to existing types without 
            //creating a new derived type, recompiling, or otherwise modifying the original 
            //type. Extension methods are a special kind of static methods, but they are called 
            //as if they are instance methods on the extended type.
            Console.WriteLine("Welcome to c#".Quote());
            var d = 12.3456789;
            var r1 = d.Round(2);
            var r2 = d.Round(4);
            Console.WriteLine(d);
            Console.WriteLine(r1);
            Console.WriteLine(r2);
            Console.WriteLine(d.FormatDouble("John"));

            //This coding style is called Fluent API. 
            //Method returns this reference.
            //You can call the method like this:
            var stu = new Student();
            stu.Greet("Timothy").Greet("Tom").Greet("Roman");
            new Student().Greet("Timothy").Greet("Tom").Greet("Roman");

            //Select Name from Magazines that cost less or equal to 60
            List<string> names = magazines.Where(x => x.Price <= 60)
                .OrderByDescending(o => o.Price).Select(m => m.Name).ToList();
            foreach (string name in names)
                Console.WriteLine(name);

            Console.WriteLine();
            List<string> names2 = (from magazine in magazines
                                   where magazine.Price <= 60
                                   orderby magazine.Price ascending
                                   select magazine.Name).ToList();
            foreach (string name in names2)
                Console.WriteLine(name);

            Console.WriteLine();
            int[] a1 = { 1, 2, 3, 4, 5 };
            int[] a2 = { 3, 4, 5, 6, 7 };
            //To get the integers appear in both arrays, without LINQ, the code will be:
            List<int> result = new List<int>();
            foreach (int val in a1)
            {
                foreach(int val2 in a2)
                {
                    if (val == val2)
                        result.Add(val);
                }
            }

            foreach (int val3 in result)
                Console.WriteLine("Intersect: {0}", val3);

            Console.WriteLine();
            List<int> result2 = a1.Intersect(a2).ToList();
            foreach (int val3 in result2)
                Console.WriteLine("Intersect: {0}", val3);
        }
    }

    public class Magazine
    {
        public int ID { get; set; }
        public string Author { get; set; }
        public string Name { get; set; }
        public decimal Price { get; set; }
    }

    public class Student
    {
        public Student Greet(string name)
        {
            Console.WriteLine($"Hello, {name}!");
            return this;
        }
    }

    //Both the extension method and the host class must be static.
    //The first parameter of extension method must be modified by this. When the method 
    //is invoked, this parameter won't appear in the parameter list, since the entity 
    //who is calling this method is exactly the parameter. That means, when calling an 
    //extension method, the argument list is always shorter than the parameter list of 
    //the declaration by one.
    public static class StringExtension
    {
        public static string Quote(this string str)
        {
            return $"\"{str}\"";
        }
    }

    static class DoubleExtension
    {
        public static double Round(this double value, int digits)
        {
            return Math.Round(value, digits);
        }

        public static string FormatDouble(this double value, string name)
        {
            return string.Format($"Player {name} earned {value:0.00} bitcoins.");
        }
    }

    public interface IWorker
    {
        string Name { get; set; }
        int YearsOfExperience { get; set; }
        string Scope { get; set; }
    }

    public class Writer : IWorker
    {
        public string Name { get; set; }
        public int YearsOfExperience { get; set; }
        public string Scope { get; set; }
        public void Write() { /*...*/ }
    }

    public class Teacher : IWorker
    {
        public string Name { get; set; }
        public int YearsOfExperience { get; set; }
        public string Scope { get; set; }
        public void Teach() { /*...*/ }
    }

    //To attach a group of extension methods to the IWorker interface, we will create a 
    //static class to extend the IWorker interface:
    //Now, you have seen how extension methods work with interfaces.But, you might 
    //ask this question: why not just declare those three Introduce methods in the 
    //interface and implement them in an abstract class? The answer is it depends.
    //If the methods are stable, which means we are not going to add Introduce4, 
    //Introduce5 ... soon, or the methods are components of the business logic, we 
    //should declare them in the interface and implement them on a proper inheritance 
    //level.Otherwise, we should use extension methods to keep those utility methods 
    //loosely-coupled with the target types.
    public static class IWorkerExtension
    {
        public static void Introduce1(this IWorker worker)
        {
            Console.WriteLine($"Hi, my name is {worker.Name}.");
        }

        public static void Introduce2(this IWorker worker)
        {
            Console.WriteLine($"My major scope is {worker.Scope}.");
        }

        public static void Introduce3(this IWorker worker)
        {
            Console.WriteLine($"I have {worker.YearsOfExperience} years experience.");
        }
    }

    //Upgrade the extension methods in the IWorkerExtension class to Fluent API style and call them in code?
    public static class IWorkerFluentAPIExtension
    {
        public static IWorker Introduce4(this IWorker worker)
        {
            Console.WriteLine($"#4, Hi, my name is {worker.Name}.");
            return worker;
        }

        public static IWorker Introduce5(this IWorker worker)
        {
            Console.WriteLine($"#5, My major scope is {worker.Scope}.");
            return worker;
        }

        public static IWorker Introduce6(this IWorker worker)
        {
            Console.WriteLine($"#6, I have {worker.YearsOfExperience} years experience.");
            return worker;
        }
    }

    public static class FormatExtension
    {
        public static string FormatWith(this double value, string format)
        {
            if(string.IsNullOrEmpty(format) || !format.Contains("{0}"))
            {
                throw new ArgumentException("Please provide a valid format template.");
            }

            return string.Format(format, value);
        }
    }
}
